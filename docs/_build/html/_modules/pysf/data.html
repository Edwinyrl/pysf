

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pysf.data &#8212; pysf 0.0.4 documentation</title>
    <link rel="stylesheet" href="../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.0.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pysf 0.0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pysf.data</h1><div class="highlight"><pre>
<span></span>

<span class="kn">from</span> <span class="nn">.logger</span> <span class="k">import</span> <span class="n">LoggingHandler</span> 
<span class="kn">from</span> <span class="nn">.splits</span> <span class="k">import</span> <span class="n">SlidingWindowTimeSeriesSplit</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">RawResiduals</span>

<span class="c1"># Core dependencies</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">KFold</span>

<span class="c1"># Dependencies for data acquisition</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">zipfile</span> <span class="k">import</span> <span class="n">ZipFile</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
    
    
<span class="k">def</span> <span class="nf">load_dummy_data_df</span><span class="p">(</span><span class="n">series_count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">timestamp_count</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">time_feature_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">series_feature_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">vs_times_series_factor</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">vs_times_timestamps_factor</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">vs_series_series_factor</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">):</span>
    <span class="n">colname_series</span> <span class="o">=</span> <span class="s1">&#39;series&#39;</span>
    <span class="n">colname_timestamp</span> <span class="o">=</span> <span class="s1">&#39;timestamp&#39;</span>
    <span class="n">colnames_time_features</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;time_label_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">time_feature_count</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">colnames_series_features</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;series_label_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">series_feature_count</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    
    <span class="n">ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">timestamp_count</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ft</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">time_feature_count</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">temp_right_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">([</span><span class="n">colname_timestamp</span><span class="p">]</span> <span class="o">+</span> <span class="n">colnames_time_features</span><span class="p">),</span> <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ts</span><span class="p">,</span> <span class="p">(</span><span class="n">ts</span> <span class="o">*</span> <span class="n">vs_times_timestamps_factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">ft</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">temp_right_df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span>
    <span class="n">temp_left_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">colname_series</span><span class="p">],</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">series_count</span><span class="p">)))</span>
    <span class="n">temp_left_df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span>
    <span class="n">temp_df</span> <span class="o">=</span> <span class="n">temp_left_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">temp_right_df</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>
    <span class="n">temp_df</span> <span class="o">=</span> <span class="n">temp_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">temp_df</span><span class="p">[</span><span class="n">colnames_time_features</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp_df</span><span class="p">[</span><span class="n">colname_series</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">vs_times_series_factor</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">temp_df</span><span class="p">[</span><span class="n">colnames_time_features</span><span class="p">]</span>
    <span class="n">dummy_vs_times_df</span> <span class="o">=</span> <span class="n">temp_df</span>
                                
    <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">series_count</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">series_feature_count</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dummy_vs_series_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">([</span><span class="n">colname_series</span><span class="p">]</span> <span class="o">+</span> <span class="n">colnames_series_features</span><span class="p">),</span> <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">vs_series_series_factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">fs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">dummy_vs_times_df</span><span class="p">,</span> <span class="n">dummy_vs_series_df</span><span class="p">)</span> 

    
<span class="k">def</span> <span class="nf">download_zipfile</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">zipped</span> <span class="o">=</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">content</span><span class="o">.</span><span class="n">content</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">zipped</span>
    
    
<span class="k">def</span> <span class="nf">download_ramsay_weather_data_dfs</span><span class="p">():</span>
    <span class="n">zipped</span> <span class="o">=</span> <span class="n">download_zipfile</span><span class="p">(</span><span class="s1">&#39;http://www.psych.mcgill.ca/misc/fda/downloads/FDAfuns/Matlab/fdaM.zip&#39;</span><span class="p">)</span>
    <span class="n">tempdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span>
    <span class="n">zipped</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">member</span><span class="o">=</span><span class="s1">&#39;examples/weather/daily.mat&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">tempdir</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">weather_data_dict</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempdir</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;examples/weather/daily.mat&#39;</span><span class="p">))</span>

    <span class="n">weather_tempav_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">weather_data_dict</span><span class="p">[</span><span class="s1">&#39;tempav&#39;</span><span class="p">])</span>
    <span class="n">weather_tempav_df</span><span class="p">[</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weather_tempav_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">weather_tempav_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">weather_tempav_df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">])</span>
    <span class="n">weather_tempav_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;variable&#39;</span> <span class="p">:</span> <span class="s1">&#39;weather_station&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span> <span class="p">:</span> <span class="s1">&#39;tempav&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#weather_tempav_df</span>
    
    <span class="n">weather_precav_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">weather_data_dict</span><span class="p">[</span><span class="s1">&#39;precav&#39;</span><span class="p">])</span>
    <span class="n">weather_precav_df</span><span class="p">[</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weather_precav_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">weather_precav_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">weather_precav_df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">])</span>
    <span class="n">weather_precav_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;variable&#39;</span> <span class="p">:</span> <span class="s1">&#39;weather_station&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span> <span class="p">:</span> <span class="s1">&#39;precav&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#weather_precav_df</span>
    
    <span class="n">weather_vs_times_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">weather_tempav_df</span><span class="p">,</span> <span class="n">weather_precav_df</span><span class="p">)</span>
    <span class="n">weather_vs_series_df</span><span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">weather_vs_times_df</span><span class="p">,</span> <span class="n">weather_vs_series_df</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">download_ramsay_growth_data_dfs</span><span class="p">():</span>
    <span class="n">zipped</span> <span class="o">=</span> <span class="n">download_zipfile</span><span class="p">(</span><span class="s1">&#39;http://www.psych.mcgill.ca/misc/fda/downloads/FDAfuns/Matlab/fdaM.zip&#39;</span><span class="p">)</span>
    <span class="n">tempdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span>
    <span class="n">zipped</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">member</span><span class="o">=</span><span class="s1">&#39;examples/growth/growth.mat&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">tempdir</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">growth_data_dict</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempdir</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;examples/growth/growth.mat&#39;</span><span class="p">))</span>

    <span class="n">ages_arr</span> <span class="o">=</span> <span class="n">growth_data_dict</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>

    <span class="n">boys_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">growth_data_dict</span><span class="p">[</span><span class="s1">&#39;hgtmmat&#39;</span><span class="p">])</span>
    <span class="n">boys_df</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ages_arr</span>
    <span class="n">boys_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">boys_df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">])</span>
    <span class="n">boys_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;variable&#39;</span> <span class="p">:</span> <span class="s1">&#39;cohort_id&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span> <span class="p">:</span> <span class="s1">&#39;height&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">boys_df</span><span class="p">[</span><span class="s1">&#39;gender&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;boy&#39;</span>
    <span class="c1">#boys_df</span>
    
    <span class="n">girls_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">growth_data_dict</span><span class="p">[</span><span class="s1">&#39;hgtfmat&#39;</span><span class="p">])</span>
    <span class="n">girls_df</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ages_arr</span>
    <span class="n">girls_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">girls_df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">])</span>
    <span class="n">girls_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;variable&#39;</span> <span class="p">:</span> <span class="s1">&#39;cohort_id&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span> <span class="p">:</span> <span class="s1">&#39;height&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">girls_df</span><span class="p">[</span><span class="s1">&#39;gender&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;girl&#39;</span>
    <span class="c1">#girls_df</span>

    <span class="n">growth_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">boys_df</span><span class="p">,</span> <span class="n">girls_df</span><span class="p">])</span>
    
    <span class="n">growth_vs_times_df</span> <span class="o">=</span> <span class="n">growth_df</span>
    <span class="n">growth_vs_series_df</span> <span class="o">=</span> <span class="n">growth_df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">growth_vs_times_df</span><span class="p">,</span> <span class="n">growth_vs_series_df</span><span class="p">)</span>
    
    
<span class="k">def</span> <span class="nf">download_ecg_data_dfs</span><span class="p">():</span>
    <span class="n">zipped</span> <span class="o">=</span> <span class="n">download_zipfile</span><span class="p">(</span><span class="s1">&#39;http://timeseriesclassification.com/Downloads/ECG200.zip&#39;</span><span class="p">)</span>
    <span class="n">tempdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span>
    <span class="n">zipped</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">member</span><span class="o">=</span><span class="s1">&#39;ECG200/ECG200.csv&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">tempdir</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">ecg_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempdir</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;ECG200/ECG200.csv&#39;</span><span class="p">)</span>
    
    <span class="n">raw_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">ecg_filepath</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">96</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;class_label&#39;</span><span class="p">]),</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
    <span class="n">raw_df</span><span class="p">[</span><span class="s1">&#39;heartbeat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>  
    <span class="n">ecg_vs_series</span> <span class="o">=</span> <span class="n">raw_df</span><span class="p">[[</span><span class="s1">&#39;heartbeat&#39;</span><span class="p">,</span> <span class="s1">&#39;class_label&#39;</span><span class="p">]]</span>     
    
    <span class="n">raw_df</span> <span class="o">=</span> <span class="n">raw_df</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;heartbeat&#39;</span><span class="p">,</span> <span class="s1">&#39;class_label&#39;</span><span class="p">])</span>
    <span class="n">raw_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;variable&#39;</span> <span class="p">:</span> <span class="s1">&#39;timestamp&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span> <span class="p">:</span> <span class="s1">&#39;potential_difference&#39;</span> <span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">raw_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ecg_vs_times</span> <span class="o">=</span> <span class="n">raw_df</span><span class="p">[[</span><span class="s1">&#39;heartbeat&#39;</span><span class="p">,</span> <span class="s1">&#39;timestamp&#39;</span><span class="p">,</span> <span class="s1">&#39;potential_difference&#39;</span><span class="p">]]</span>
    
    <span class="n">ecg_vs_series</span><span class="p">[</span><span class="s1">&#39;is_abnormal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ecg_vs_series</span><span class="p">[</span><span class="s1">&#39;class_label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ecg_vs_series</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;class_label&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ecg_vs_times</span><span class="p">,</span> <span class="n">ecg_vs_series</span><span class="p">)</span>
    
    
<span class="c1"># Design patterns used: Flyweight, Prototype.</span>
<div class="viewcode-block" id="MultiSeries"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries">[docs]</a><span class="k">class</span> <span class="nc">MultiSeries</span><span class="p">(</span><span class="n">LoggingHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The summary line for a class docstring should fit on one line.</span>

<span class="sd">    If the class has public attributes, they may be documented here</span>
<span class="sd">    in an ``Attributes`` section and follow the same formatting as a</span>
<span class="sd">    function&#39;s ``Args`` section. Alternatively, attributes may be documented</span>
<span class="sd">    inline with the attribute&#39;s declaration (see __init__ method below).</span>

<span class="sd">    Properties created with the ``@property`` decorator should be documented</span>
<span class="sd">    in the property&#39;s getter method.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        attr1 (str): Description of `attr1`.</span>
<span class="sd">        attr2 (:obj:`int`, optional): Description of `attr2`.</span>

<span class="sd">    &quot;&quot;&quot;</span>       
    
    <span class="c1"># Pythonic way of doing read-only properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">count_features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span>
        
    <span class="c1"># Pythonic way of doing read-only properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_non_timestamp_feature_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># Pythonic way of doing read-only properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">count_observations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_obs_vs_times</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">def</span> <span class="nf">_inferValueColnames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_df</span><span class="p">,</span> <span class="n">time_colname</span><span class="p">,</span> <span class="n">series_id_colnames</span><span class="p">,</span> <span class="n">value_colnames</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">check_presence_of_time_colname</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_colnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_presence_of_time_colname</span> <span class="ow">and</span> <span class="n">time_colname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_colnames</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;time_colname &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time_colname</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; is not a column of the given data_df&#39;</span><span class="p">)</span>    
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">series_id_colnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_colnames</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;series_id_colnames item &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; is not a column of the given data_df&#39;</span><span class="p">)</span>
            <span class="n">given_colnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_colname</span><span class="p">]</span> <span class="o">+</span> <span class="n">series_id_colnames</span>
            <span class="k">if</span> <span class="n">value_colnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;value_colnames was not specified, so will infer from the data frame.&#39;</span><span class="p">)</span>
                <span class="n">other_colnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_colnames</span><span class="p">,</span> <span class="n">given_colnames</span><span class="p">))</span>
                <span class="n">value_colnames</span> <span class="o">=</span> <span class="n">other_colnames</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Inferred &#39;</span> <span class="o">+</span> <span class="n">description</span> <span class="o">+</span><span class="s1">&#39; value colnames = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value_colnames</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">given_colnames</span> <span class="o">=</span> <span class="n">given_colnames</span> <span class="o">+</span> <span class="n">value_colnames</span>
                <span class="n">other_colnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_colnames</span><span class="p">,</span> <span class="n">given_colnames</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The following col names will be dropped: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">other_colnames</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">value_colnames</span>
            
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_colname</span><span class="p">,</span> <span class="n">series_id_colnames</span><span class="p">,</span> <span class="n">data_vs_times_df</span><span class="p">,</span> <span class="n">data_vs_series_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value_colnames_vs_series</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiSeries</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        
        <span class="c1"># Validation...</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data_vs_times_df</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;data_vs_times_df must be a pandas DataFrame! Was &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data_vs_times_df</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; instead.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">data_vs_series_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">data_vs_series_df</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;data_vs_series_df must be a pandas DataFrame! Was &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data_vs_series_df</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; instead.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">time_colname</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;time_colname must be a string! Was &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">time_colname</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; instead.&#39;</span><span class="p">)</span>
        
        <span class="n">str_shape_data_vs_times_df</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
        <span class="k">if</span> <span class="n">data_vs_times_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">str_shape_data_vs_times_df</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data_vs_times_df</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">str_shape_data_vs_series_df</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
        <span class="k">if</span> <span class="n">data_vs_series_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">str_shape_data_vs_series_df</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data_vs_series_df</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Initialising MultiSeries: data_vs_times_df.shape = &#39;</span> <span class="o">+</span> <span class="n">str_shape_data_vs_times_df</span> <span class="o">+</span> <span class="s1">&#39;, data_vs_times_df.shape = &#39;</span> <span class="o">+</span> <span class="n">str_shape_data_vs_series_df</span> <span class="o">+</span> <span class="s1">&#39;, time_colname = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time_colname</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, series_id_colnames = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">series_id_colnames</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, value_colnames_vs_times = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value_colnames_vs_times</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, value_colnames_vs_series = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value_colnames_vs_series</span><span class="p">))</span>
        
        <span class="c1"># ... continued</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">series_id_colnames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">series_id_colnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">series_id_colnames</span><span class="p">]</span> <span class="c1"># for convenience</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value_colnames_vs_times</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">value_colnames_vs_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_colnames_vs_times</span><span class="p">]</span> <span class="c1"># for convenience</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value_colnames_vs_series</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">value_colnames_vs_series</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_colnames_vs_series</span><span class="p">]</span> <span class="c1"># for convenience</span>
                        
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span> <span class="o">=</span> <span class="n">time_colname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames</span> <span class="o">=</span> <span class="n">series_id_colnames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inferValueColnames</span><span class="p">(</span><span class="n">data_df</span><span class="o">=</span><span class="n">data_vs_times_df</span><span class="p">,</span> <span class="n">value_colnames</span><span class="o">=</span><span class="n">value_colnames_vs_times</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;time-label&#39;</span><span class="p">,</span> <span class="n">time_colname</span><span class="o">=</span><span class="n">time_colname</span><span class="p">,</span> <span class="n">series_id_colnames</span><span class="o">=</span><span class="n">series_id_colnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inferValueColnames</span><span class="p">(</span><span class="n">data_df</span><span class="o">=</span><span class="n">data_vs_series_df</span><span class="p">,</span> <span class="n">value_colnames</span><span class="o">=</span><span class="n">value_colnames_vs_series</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;series-label&#39;</span><span class="p">,</span> <span class="n">time_colname</span><span class="o">=</span><span class="n">time_colname</span><span class="p">,</span> <span class="n">series_id_colnames</span><span class="o">=</span><span class="n">series_id_colnames</span><span class="p">,</span> <span class="n">check_presence_of_time_colname</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Define a mapping between multiple series_id_colnames and a single identifier column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span> <span class="o">=</span> <span class="s1">&#39;***internal_series_id***&#39;</span> <span class="c1"># don&#39;t clash with anything</span>
        <span class="k">if</span> <span class="n">data_vs_times_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">data_vs_series_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data_vs_series_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Special column &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span> <span class="o">+</span> <span class="s1">&#39; already exists!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span> <span class="o">=</span> <span class="n">data_vs_times_df</span><span class="p">[</span><span class="n">series_id_colnames</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">data_vs_series_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">part_two</span> <span class="o">=</span> <span class="n">data_vs_series_df</span><span class="p">[</span><span class="n">series_id_colnames</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span><span class="p">,</span> <span class="n">part_two</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
            
        <span class="c1"># Replace multiple series_id_colnames with a single idenfier column, for the time-label DF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span> <span class="o">=</span> <span class="n">data_vs_times_df</span><span class="p">[[</span><span class="n">time_colname</span><span class="p">]</span> <span class="o">+</span> <span class="n">series_id_colnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># take a copy before we start modifying it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames</span><span class="p">)</span>
        
        <span class="c1"># Replace multiple series_id_colnames with a single idenfier column, for the series-label DF</span>
        <span class="k">if</span> <span class="n">data_vs_series_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span> <span class="o">=</span> <span class="n">data_vs_series_df</span><span class="p">[</span><span class="n">series_id_colnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># take a copy before we start modifying it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames</span><span class="p">)</span>
        
        <span class="c1"># After merging by columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colnames_mapping</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">)</span>
            
        <span class="c1"># Validation of DF contents, for the time-label DF only</span>
        <span class="n">counts_by_time_and_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">counts_by_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">counts_by_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count_time_indices</span> <span class="o">=</span> <span class="n">counts_by_time</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count_series_indices</span> <span class="o">=</span> <span class="n">counts_by_series</span><span class="o">.</span><span class="n">size</span>
        <span class="n">duplicate_observations</span> <span class="o">=</span> <span class="n">counts_by_time_and_series</span><span class="p">[</span><span class="n">counts_by_time_and_series</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">duplicate_observations</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There are &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">duplicate_observations</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; instances of more than one observation per series index + time index! Should be 0 instances.&#39;</span><span class="p">)</span>
        <span class="n">missing_observations</span> <span class="o">=</span> <span class="n">counts_by_time</span><span class="p">[</span><span class="n">counts_by_time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_series_indices</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">missing_observations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">missing_observations</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; time indices have missing series observations&#39;</span><span class="p">)</span>
        <span class="n">missing_observations</span> <span class="o">=</span> <span class="n">counts_by_series</span><span class="p">[</span><span class="n">counts_by_series</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_time_indices</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">missing_observations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">missing_observations</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; series indices have missing time observations&#39;</span><span class="p">)</span>
                        
        <span class="c1"># Sort by single series identifier (for reproducibility) and time (to ensure CV works!)</span>
        <span class="c1"># MultiIndex requires data to be sorted to work properly (source: http://pandas.pydata.org/pandas-docs/version/0.18.1/advanced.html)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">])</span>
        
        <span class="c1"># I&#39;ve never had cause to use this, so have left it commented for now.</span>
        <span class="c1"># Drop any NA observations that are being passed in, now that we have extracted series &amp; timestamp info. from them</span>
        <span class="c1">#self._data_vs_times_df = self._data_vs_times_df.dropna().reset_index(drop=True)</span>
        <span class="c1">#if self._data_vs_series_df is not None:</span>
        <span class="c1">#    self._data_vs_series_df = self._data_vs_series_df.dropna().reset_index(drop=True)</span>
        
        <span class="c1"># Set an index consisting of series identifier and time, for the time-label DF...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">])</span> 
        
        <span class="c1"># ... and by series identifier only, for the series-label DF</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">])</span> 
            
        <span class="c1"># Prepare an index to filter the rows we care about, for the time-label DF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span> <span class="c1"># cached here for efficiency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span>           <span class="c1"># cached here for efficiency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_derived_filters</span><span class="p">()</span>
    
        
    <span class="k">def</span> <span class="nf">_set_derived_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This filter is for all possible combinations of values. Any non-observed values will appear as np.nan:s when it is used to index the data DF:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_grid</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">])</span>
        <span class="c1"># Filter only for time indices with a full suite of observations:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_times_with_full_observations</span><span class="p">()</span>
        <span class="c1"># TODO: is this efficient, or are we better off indexing using [ , ] instead of levels.isin():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_full</span><span class="p">)]</span>

                                             
    <span class="k">def</span> <span class="nf">_get_times_with_full_observations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">count_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_obs_vs_times</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">)</span> 
        <span class="n">full_obs</span> <span class="o">=</span> <span class="n">count_obs</span><span class="p">[</span><span class="n">count_obs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_series_indices</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">time_full</span> <span class="o">=</span> <span class="n">full_obs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">time_full</span>
         
        
    <span class="c1"># Use the current filter to select a dataframe of all observations</span>
    <span class="k">def</span> <span class="nf">_select_df_obs_vs_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="p">,</span> <span class="p">:]</span>
        
        
    <span class="c1"># Use the current filter to select a dataframe of a grid of all observations + missing values</span>
    <span class="k">def</span> <span class="nf">_select_df_grid_vs_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_grid</span><span class="p">,</span> <span class="p">:]</span>
        
        
    <span class="c1"># Use the current filter to select a dataframe of a grid of only fully-observed times,</span>
    <span class="c1"># where fully-observed is defined with respect to the series in this filter (and not globally).</span>
    <span class="k">def</span> <span class="nf">_select_df_full_vs_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_full</span><span class="p">,</span> <span class="p">:]</span>
        
        
    <span class="c1"># Convenience method</span>
    <span class="k">def</span> <span class="nf">_select_df_vs_times_and_times_switch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">allow_missing_values</span><span class="p">:</span>
            <span class="n">df_vs_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_grid_vs_times</span><span class="p">()</span> <span class="c1"># return a full grid</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df_vs_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_full_vs_times</span><span class="p">()</span> <span class="c1"># return only fully-observed timestamps</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_full</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">df_vs_times</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>
        
        
    <span class="c1"># Convenience method</span>
    <span class="k">def</span> <span class="nf">_select_df_vs_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df_vs_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_series_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">df_vs_series</span>
        
    
    <span class="c1"># Returns a 3-item tuple consisting of (a 3-D array of time-label data, a 2-D array of series-label data, a 1D array of time values). </span>
    <span class="c1"># The 3-D array has shape (# series, # timestamps, # time_features) and the 2-D array has shape (# series, # series_features),</span>
    <span class="c1"># where #time_features &amp; #series_features depend on the values supplied for value_colnames_filter &amp; include_time_as_feature.</span>
    <span class="c1"># Missing observations are replaced by np.nan if applicable.</span>
<div class="viewcode-block" id="MultiSeries.select_arrays"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.select_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">select_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">df_vs_times</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_vs_times_and_times_switch</span><span class="p">(</span><span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">)</span>
        <span class="n">df_vs_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_vs_series</span><span class="p">()</span>
        
        <span class="c1"># Filter by time-label &amp; series-label names</span>
        <span class="n">selection_count_features</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">value_colnames_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selection_count_features</span> <span class="o">=</span> <span class="n">selection_count_features</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_features</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value_colnames_filter</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">value_colnames_filter</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_colnames_filter</span><span class="p">]</span> <span class="c1"># for convenience</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Filtering by the following value colname(s): &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value_colnames_filter</span><span class="p">))</span>
            
            <span class="c1"># These may be slightly inefficient, but it&#39;s important to avoid non-deterministically re-ordering the feature columns, which</span>
            <span class="c1"># is what would happpen if we were to do something like this: value_colnames_filter_vs_times = list(set(value_colnames_filter) &amp; set(self._value_colnames_vs_times))</span>
            <span class="n">value_colnames_filter_vs_times</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value_colnames_filter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span><span class="p">:</span>
                    <span class="n">value_colnames_filter_vs_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            
            <span class="c1">#set_value_colnames_filter = set(value_colnames_filter)</span>
            <span class="c1">#value_colnames_filter_vs_times = list(set_value_colnames_filter &amp; set(self._value_colnames_vs_times))</span>
            <span class="n">df_vs_times</span> <span class="o">=</span> <span class="n">df_vs_times</span><span class="p">[</span><span class="n">value_colnames_filter_vs_times</span><span class="p">]</span>
            <span class="n">selection_count_features</span> <span class="o">=</span> <span class="n">selection_count_features</span> <span class="o">+</span> <span class="n">df_vs_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">df_vs_series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                
                <span class="c1"># Same NB. as before for this one:</span>
                <span class="n">value_colnames_filter_vs_series</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value_colnames_filter</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span><span class="p">:</span>
                        <span class="n">value_colnames_filter_vs_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                
                <span class="n">df_vs_series</span> <span class="o">=</span> <span class="n">df_vs_series</span><span class="p">[</span><span class="n">value_colnames_filter_vs_series</span><span class="p">]</span>
                <span class="n">selection_count_features</span> <span class="o">=</span> <span class="n">selection_count_features</span> <span class="o">+</span> <span class="n">df_vs_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Explicitly include the time column as a feature, if requested</span>
        <span class="k">if</span> <span class="n">include_time_as_feature</span><span class="p">:</span>
            <span class="n">df_vs_times</span> <span class="o">=</span> <span class="n">df_vs_times</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">)</span>
            <span class="n">selection_count_features</span> <span class="o">=</span> <span class="n">selection_count_features</span> <span class="o">+</span> <span class="mi">1</span>
            
        <span class="c1"># Prepare the 3-D array of time-label data</span>
        <span class="c1"># TODO: is this efficient, or are we better off extracting col-by-col:</span>
        <span class="n">a3d_vs_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">df_vs_times</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">)))</span>
        <span class="n">a3d_vs_times_shape</span> <span class="o">=</span> <span class="n">a3d_vs_times</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Converting the filtered dataframe with shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">df_vs_times</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; to a 3D array of (series, time, features) with shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a3d_vs_times_shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a3d_vs_times_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a3d_vs_times_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Explicitly Reshaping the 2D time-label array &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a3d_vs_times_shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; to be 3D, since it only has a single feature&#39;</span><span class="p">)</span>
                <span class="n">a3d_vs_times</span> <span class="o">=</span> <span class="n">a3d_vs_times</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a3d_vs_times_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a3d_vs_times_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There appear to be no valid time labels, based on the given criteria! The returned array is not 3-dimensional. It has shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a3d_vs_times_shape</span><span class="p">))</span>
           
        <span class="c1"># Prepare the 2-D array of series-label data</span>
        <span class="k">if</span> <span class="n">df_vs_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a2d_vs_series</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a2d_vs_series</span> <span class="o">=</span> <span class="n">df_vs_series</span><span class="o">.</span><span class="n">values</span>
            <span class="n">a2d_vs_series_shape</span> <span class="o">=</span> <span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a2d_vs_series_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a2d_vs_series_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Explicitly Reshaping the 1D series-label array &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a2d_vs_series_shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; to be 2D, since it only has a single feature&#39;</span><span class="p">)</span>
                    <span class="n">a2d_vs_series</span> <span class="o">=</span> <span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># reshaping to have a single feature, SKLearn-style</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There appear to be no valid series labels, based on the given criteria! The returned array is not 2-dimensional. It has shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a2d_vs_series_shape</span><span class="p">))</span>
                
        <span class="k">return</span> <span class="p">(</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span></div>
        
        
    <span class="c1"># Returns a 2-item tuple consisting of (a 3-D array of the data, a 1D array of time values). </span>
    <span class="c1"># The 3-D array has shape (# series, # timestamps, # time_features + #series_features)</span>
    <span class="c1"># where #time_features &amp; #series_features depend on the values supplied for value_colnames_filter &amp; include_time_as_feature.</span>
    <span class="c1"># Missing observations are replaced by np.nan if applicable.</span>
<div class="viewcode-block" id="MultiSeries.select_merged_3d_array"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.select_merged_3d_array">[docs]</a>    <span class="k">def</span> <span class="nf">select_merged_3d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_arrays</span><span class="p">(</span><span class="n">include_time_as_feature</span><span class="o">=</span><span class="n">include_time_as_feature</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="n">value_colnames_filter</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">)</span>
        <span class="c1">#print(a3d_vs_times.shape)   # (186, 31, 1)</span>
        <span class="c1">#print(a2d_vs_series.shape)  # (186, 2)</span>
        <span class="c1">#print(a1d_times.shape)      # (31,)</span>

        <span class="k">if</span> <span class="n">a2d_vs_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a3d_all</span> <span class="o">=</span> <span class="n">a3d_vs_times</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Add a time dimension of 1 (in between the series &amp; feature dims)</span>
            <span class="n">a3d_vs_series</span> <span class="o">=</span> <span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c1">#print(a3d_vs_series.shape)   # (186, 1, 2)</span>
            
            <span class="c1"># Broadcast this new time dimension from a size of 1 to the # timestamps</span>
            <span class="n">a3d_vs_series</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a3d_vs_series</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="n">a3d_vs_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#print(a3d_vs_series.shape)   # (186, 31, 2)</span>
            
            <span class="n">a3d_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">a3d_vs_series</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1">#print(a3d_all.shape)   # (186, 31, 3)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">a3d_all</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span></div>
        
        
    <span class="c1"># Returns a 2-item tuple consisting of (a 2-D array of the data, a 1D array of time values). </span>
    <span class="c1"># The 2-D array has shape (# series, # timestamps * # time_features + #series_features)</span>
    <span class="c1"># where #time_features &amp; #series_features depend on the values supplied for value_colnames_filter &amp; include_time_as_feature.</span>
    <span class="c1"># Missing observations are replaced by np.nan if applicable.</span>
<div class="viewcode-block" id="MultiSeries.select_tabular_full_2d_array"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.select_tabular_full_2d_array">[docs]</a>    <span class="k">def</span> <span class="nf">select_tabular_full_2d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_arrays</span><span class="p">(</span><span class="n">include_time_as_feature</span><span class="o">=</span><span class="n">include_time_as_feature</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="n">value_colnames_filter</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">)</span>
        <span class="c1">#print(a3d_vs_times.shape)   # (186, 31, 1)</span>
        <span class="c1">#print(a2d_vs_series.shape)  # (186, 2)</span>
        <span class="c1">#print(a1d_times.shape)      # (31,)     </span>
    
        <span class="c1"># Flatten over the time &amp; time-feature dimensions</span>
        <span class="n">a2d_vs_times</span> <span class="o">=</span> <span class="n">a3d_vs_times</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">a3d_vs_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a3d_vs_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3d_vs_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="c1">#print(a2d_vs_times.shape)   # (186, 31)</span>
        
        <span class="k">if</span> <span class="n">a2d_vs_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a2d_all</span> <span class="o">=</span> <span class="n">a2d_vs_times</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a2d_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a2d_vs_times</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#print(a2d_all.shape)   # (186, 33)</span>
            
        <span class="k">return</span> <span class="p">(</span><span class="n">a2d_all</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span></div>
        
    
    <span class="c1"># Given an input_window_size and output_window_size, as well as the usual parameters.</span>
    <span class="c1"># Returns a 4-item tuple consisting of (a 4-D array of the input X time-labelled data, a 4-D array of the output Y time-labelled data, a 2-D array of series labels, # splits).</span>
<div class="viewcode-block" id="MultiSeries.select_paired_tabular_windowed_arrays"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.select_paired_tabular_windowed_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">select_paired_tabular_windowed_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Explicitly convert floats to ints</span>
        <span class="n">input_sliding_window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_sliding_window_size</span><span class="p">)</span>
        <span class="n">output_sliding_window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">output_sliding_window_size</span><span class="p">)</span>
        
        <span class="p">(</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_arrays</span><span class="p">(</span><span class="n">include_time_as_feature</span><span class="o">=</span><span class="n">include_time_as_feature</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="n">value_colnames_filter</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">)</span>
        
        <span class="c1">#print(input_sliding_window_size)    # 3</span>
        <span class="c1">#print(output_sliding_window_size)   # 2</span>
        <span class="c1">#print(a3d_vs_times.shape)           # (93, 31, 1)</span>
        <span class="c1">#print(a2d_vs_series.shape)          # (93, 2)</span>
        
        <span class="c1"># Create 2 arrays all_input_time_indices + all_output_time_indices </span>
        <span class="c1"># of shapes (#splits, input_sliding_window_size) + (#splits, output_sliding_window_size), respectively.</span>
        <span class="n">time_splitter</span> <span class="o">=</span> <span class="n">SlidingWindowTimeSeriesSplit</span><span class="p">(</span><span class="n">count_timestamps</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">a1d_times</span><span class="p">),</span> <span class="n">training_set_size</span><span class="o">=</span><span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">validation_set_size</span><span class="o">=</span><span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num_splits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_splitter</span><span class="p">)</span>
        <span class="n">all_input_time_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_splits</span><span class="p">,</span> <span class="n">input_sliding_window_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">all_output_time_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_splits</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">split_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">input_time_indices</span><span class="p">,</span> <span class="n">output_time_indices</span><span class="p">)</span> <span class="ow">in</span> <span class="n">time_splitter</span><span class="p">:</span>
            <span class="n">all_input_time_indices</span><span class="p">[</span><span class="n">split_idx</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">input_time_indices</span>
            <span class="n">all_output_time_indices</span><span class="p">[</span><span class="n">split_idx</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">output_time_indices</span>
            <span class="n">split_idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">split_idx</span>
            
        <span class="c1"># Transform the 3-D array of time labels from (# series, # timestamps, # time_features)</span>
        <span class="c1"># to pair of 4-D arrays with shapes (# series, # splits, window_size, # time_features)</span>
        <span class="c1"># where window size is the input or output window, as appropriate.</span>
        <span class="n">a4d_vs_times_windowed_input</span> <span class="o">=</span> <span class="n">a3d_vs_times</span><span class="p">[:,</span> <span class="n">all_input_time_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">a4d_vs_times_windowed_output</span> <span class="o">=</span> <span class="n">a3d_vs_times</span><span class="p">[:,</span> <span class="n">all_output_time_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1">#print(a4d_vs_times_windowed_input.shape)    # (93, 27, 3, 1)</span>
        <span class="c1">#print(a4d_vs_times_windowed_output.shape)   # (93, 27, 2, 1)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">a4d_vs_times_windowed_input</span><span class="p">,</span> <span class="n">a4d_vs_times_windowed_output</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">num_splits</span><span class="p">)</span></div>
       
    
    <span class="c1"># Returns a 2-item tuple of 4-D arrays:</span>
    <span class="c1">#   - first item has shape (# series, # splits, input_sliding_window_size, # features)</span>
    <span class="c1">#   - second item has shape (# series, # splits, output_sliding_window_size, # features)</span>
    <span class="c1"># and # features includes both time-labels and (broadcast) series-labels, where appropriate</span>
<div class="viewcode-block" id="MultiSeries.select_paired_tabular_windowed_4d_arrays"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.select_paired_tabular_windowed_4d_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">select_paired_tabular_windowed_4d_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">a4d_vs_times_windowed_input</span><span class="p">,</span> <span class="n">a4d_vs_times_windowed_output</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">num_splits</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_paired_tabular_windowed_arrays</span><span class="p">(</span><span class="n">input_sliding_window_size</span><span class="o">=</span><span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="o">=</span><span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="n">include_time_as_feature</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="n">value_colnames_filter</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">)</span>
        <span class="c1">#print(&#39;a4d_vs_times_windowed_input.shape = &#39; + str(a4d_vs_times_windowed_input.shape))            # (93, 17, 10, 1)</span>
        <span class="c1">#print(&#39;a4d_vs_times_windowed_output.shape = &#39; + str(a4d_vs_times_windowed_output.shape))          # (93, 17, 5, 1)</span>
        <span class="c1">#print(&#39;a2d_vs_series.shape = &#39; + str(a2d_vs_series.shape))                                        # (93, 2)</span>
        <span class="c1">#print(&#39;num_splits = &#39; + str(num_splits))                                                          # 17</span>
        
        <span class="k">if</span> <span class="n">a2d_vs_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a4d_vs_times_windowed_input_all</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_input</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Reshape and then explicitly broadcast along the 2 new axes:</span>
            <span class="n">a4d_vs_series</span> <span class="o">=</span> <span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">a4d_vs_series</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a4d_vs_series</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="n">num_splits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">a4d_vs_series</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a4d_vs_series</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1">#print(&#39;a4d_vs_series.shape = &#39; + str(a4d_vs_series.shape))                                        # (93, 17, 10, 2)</span>
            <span class="n">a4d_vs_times_windowed_input_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a4d_vs_times_windowed_input</span><span class="p">,</span> <span class="n">a4d_vs_series</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1">#print(&#39;a4d_vs_times_windowed_input_all.shape = &#39; + str(a4d_vs_times_windowed_input_all.shape))    # (93, 17, 10, 3)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">a4d_vs_times_windowed_input_all</span><span class="p">,</span> <span class="n">a4d_vs_times_windowed_output</span><span class="p">)</span></div>
    
    
    <span class="c1"># Returns a 2-item tuple of 3-D arrays:</span>
    <span class="c1">#   - first item has shape (# series * # splits, input_sliding_window_size, # features)</span>
    <span class="c1">#   - second item has shape (# series * # splits, output_sliding_window_size, # features)</span>
    <span class="c1"># and # features includes both time-labels and (broadcast) series-labels, where appropriate</span>
<div class="viewcode-block" id="MultiSeries.select_paired_tabular_windowed_3d_by_time_arrays"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.select_paired_tabular_windowed_3d_by_time_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">select_paired_tabular_windowed_3d_by_time_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">a4d_vs_times_windowed_input</span><span class="p">,</span> <span class="n">a4d_vs_times_windowed_output</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">num_splits</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_paired_tabular_windowed_arrays</span><span class="p">(</span><span class="n">input_sliding_window_size</span><span class="o">=</span><span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="o">=</span><span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="n">include_time_as_feature</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="n">value_colnames_filter</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">)</span>
        <span class="n">a4d_shape_input</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_input</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">a4d_shape_output</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_output</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">a3d_vs_times_windowed_input</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a4d_shape_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a4d_shape_input</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a4d_shape_input</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a4d_shape_input</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">a3d_vs_times_windowed_output</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a4d_shape_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a4d_shape_output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a4d_shape_output</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a4d_shape_output</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a3d_vs_times_windowed_input</span><span class="p">,</span> <span class="n">a3d_vs_times_windowed_output</span><span class="p">)</span></div>
        
        
    <span class="c1"># Given an input_window_size and output_window_size, as well as the usual parameters.</span>
    <span class="c1"># Returns a 2-item tuple consisting of (a 3-D array of the input X data, a 3-D array of the output Y data).</span>
    <span class="c1"># Each 3-D array will have the shape (#series, #splits, window_size * #time_features + #series_features),</span>
    <span class="c1"># where window_size depends on which element of the tuple we are looking at.</span>
<div class="viewcode-block" id="MultiSeries.select_paired_tabular_windowed_3d_by_series_arrays"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.select_paired_tabular_windowed_3d_by_series_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">select_paired_tabular_windowed_3d_by_series_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">a4d_vs_times_windowed_input</span><span class="p">,</span> <span class="n">a4d_vs_times_windowed_output</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">num_splits</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_paired_tabular_windowed_arrays</span><span class="p">(</span><span class="n">input_sliding_window_size</span><span class="o">=</span><span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="o">=</span><span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="n">include_time_as_feature</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="n">value_colnames_filter</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">)</span>
        
        <span class="c1"># And then transform again to 3-D arrays with shapes (# series, # splits, window_size * # time_features)</span>
        <span class="n">a4d_shape_input</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_input</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">a4d_shape_output</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_output</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">a3d_vs_times_windowed_input</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a4d_shape_input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a4d_shape_input</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a4d_shape_input</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">a4d_shape_input</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">a3d_vs_times_windowed_output</span> <span class="o">=</span> <span class="n">a4d_vs_times_windowed_output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a4d_shape_output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a4d_shape_output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a4d_shape_output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">a4d_shape_output</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="c1">#print(a3d_vs_times_windowed_input.shape)    # (93, 27, 3)</span>
        <span class="c1">#print(a3d_vs_times_windowed_output.shape)   # (93, 27, 2)</span>
        
        <span class="k">if</span> <span class="n">a2d_vs_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a3d_vs_times_windowed_input</span><span class="p">,</span> <span class="n">a3d_vs_times_windowed_output</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For the 2-D series, add a split dimension of 1 (in between the series &amp; feature dims)</span>
            <span class="n">a3d_vs_series</span> <span class="o">=</span> <span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c1">#print(a3d_vs_series.shape)   # (93, 1, 2)</span>
            
            <span class="c1"># Broadcast this new split dimension from a size of 1 to the # splits</span>
            <span class="n">a3d_vs_series</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a3d_vs_series</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="n">num_splits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#print(a3d_vs_series.shape)   # (93, 27, 2)</span>
            
            <span class="c1"># Finally, combine the series with time data to have arrays of shape:</span>
            <span class="c1"># (#series, #splits, window_size * #time_features + #series_features)</span>
            <span class="n">a3d_all_windowed_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a3d_vs_times_windowed_input</span><span class="p">,</span> <span class="n">a3d_vs_series</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">a3d_all_windowed_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a3d_vs_times_windowed_output</span><span class="p">,</span> <span class="n">a3d_vs_series</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1">#print(a3d_all_windowed_input.shape)    # (93, 27, 5)</span>
            <span class="c1">#print(a3d_all_windowed_output.shape)   # (93, 27, 4)</span>
            
            <span class="k">return</span> <span class="p">(</span><span class="n">a3d_all_windowed_input</span><span class="p">,</span> <span class="n">a3d_all_windowed_output</span><span class="p">)</span></div>

        
    <span class="c1"># This is a convenience method that converts the results of select_paired_tabular_windowed_2d_arrays(), which are each in shape (#series, #splits, window_size * #time_features + #series_features),</span>
    <span class="c1"># to the sklearn-compatible shape of (#series * #splits, window_size * #time_features + #series_features)</span>
    <span class="c1">#   i.e. n_samples = #series * #splits</span>
    <span class="c1">#   and  n_features = window_size * #time_features + #series_features</span>
    <span class="c1"># in sklearn&#39;s nomenclature.</span>
<div class="viewcode-block" id="MultiSeries.select_paired_tabular_windowed_2d_arrays"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.select_paired_tabular_windowed_2d_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">select_paired_tabular_windowed_2d_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">a3d_all_windowed_input</span><span class="p">,</span> <span class="n">a3d_all_windowed_output</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_paired_tabular_windowed_3d_by_series_arrays</span><span class="p">(</span><span class="n">input_sliding_window_size</span><span class="o">=</span><span class="n">input_sliding_window_size</span><span class="p">,</span> <span class="n">output_sliding_window_size</span><span class="o">=</span><span class="n">output_sliding_window_size</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="n">include_time_as_feature</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="n">value_colnames_filter</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">)</span>
        <span class="n">a3d_shape_input</span> <span class="o">=</span> <span class="n">a3d_all_windowed_input</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">a3d_shape_output</span> <span class="o">=</span> <span class="n">a3d_all_windowed_output</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">a2d_all_windowed_input</span>  <span class="o">=</span> <span class="n">a3d_all_windowed_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="p">(</span><span class="n">a3d_shape_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">*</span> <span class="n">a3d_shape_input</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="n">a3d_shape_input</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">))</span>
        <span class="n">a2d_all_windowed_output</span> <span class="o">=</span> <span class="n">a3d_all_windowed_output</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">a3d_shape_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3d_shape_output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a3d_shape_output</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a2d_all_windowed_input</span><span class="p">,</span> <span class="n">a2d_all_windowed_output</span><span class="p">)</span></div>
        
        
    <span class="c1"># Plot with the time as the X-axis, the series as a group, and the feature as a separate chart.</span>
<div class="viewcode-block" id="MultiSeries.visualise_arrays"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.visualise_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">visualise_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_time_as_feature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="p">(</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">a2d_vs_series</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_arrays</span><span class="p">(</span><span class="n">include_time_as_feature</span><span class="o">=</span><span class="n">include_time_as_feature</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="n">allow_missing_values</span><span class="p">,</span> <span class="n">value_colnames_filter</span><span class="o">=</span><span class="n">value_colnames_filter</span><span class="p">)</span>
        <span class="n">MultiSeries</span><span class="o">.</span><span class="n">visualise_external_3d_array</span><span class="p">(</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">a1d_times</span><span class="p">)</span>
        <span class="n">MultiSeries</span><span class="o">.</span><span class="n">visualise_external_2d_array</span><span class="p">(</span><span class="n">a2d_vs_series</span><span class="p">)</span></div>
    
        
    <span class="c1"># Pythonic (public) static helper method</span>
<div class="viewcode-block" id="MultiSeries.visualise_external_3d_array"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.visualise_external_3d_array">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">visualise_external_3d_array</span><span class="p">(</span><span class="n">a3d</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">feature_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="c1">#print(feature_idx)</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">series_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a3d</span><span class="p">[:,:,</span><span class="n">feature_idx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">a3d</span><span class="p">[</span><span class="n">series_idx</span><span class="p">,:,</span><span class="n">feature_idx</span><span class="p">]</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time value&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;value, grouped by series&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;feature index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">feature_idx</span><span class="p">))</span></div>
          
                
    <span class="c1"># Pythonic (public) static helper method</span>
<div class="viewcode-block" id="MultiSeries.visualise_external_2d_array"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.visualise_external_2d_array">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">visualise_external_2d_array</span><span class="p">(</span><span class="n">a2d</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a2d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">series_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">a2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">feature_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#print(feature_idx)</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">a2d</span><span class="p">[:,</span><span class="n">feature_idx</span><span class="p">]</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">series_idxs</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;series index&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;feature value&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;feature index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">feature_idx</span><span class="p">))</span></div>
                          
                
<div class="viewcode-block" id="MultiSeries.visualise"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.visualise">[docs]</a>    <span class="k">def</span> <span class="nf">visualise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_value_colnames</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_value_colnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_value_colnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_non_timestamp_feature_names</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">filter_value_colnames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">filter_value_colnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">filter_value_colnames</span><span class="p">]</span> <span class="c1"># required</span>
        <span class="k">for</span> <span class="n">value_colname</span> <span class="ow">in</span> <span class="n">filter_value_colnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value_colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_obs_vs_times</span><span class="p">()[</span><span class="n">value_colname</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">value_colname</span><span class="p">)</span>                
                <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span> <span class="c1"># to prevent overwriting</span>
                <span class="n">series_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_vs_series</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">series_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">series_df</span><span class="p">[</span><span class="n">value_colname</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;series&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">value_colname</span><span class="p">)</span>  
                <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Unknown feature &#39;</span> <span class="o">+</span> <span class="n">value_colname</span><span class="p">)</span></div>
                
        
<div class="viewcode-block" id="MultiSeries.visualise_moments"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.visualise_moments">[docs]</a>    <span class="k">def</span> <span class="nf">visualise_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_value_colnames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stdev_bar_multiple</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_value_colnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_value_colnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">filter_value_colnames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">filter_value_colnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">filter_value_colnames</span><span class="p">]</span> <span class="c1"># required</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value_colname</span> <span class="ow">in</span> <span class="n">filter_value_colnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value_colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span> <span class="c1"># force-start a new figure to avoid overlaying</span>
                <span class="n">grouped_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_obs_vs_times</span><span class="p">()[</span><span class="n">value_colname</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">)</span> <span class="c1"># need to explicitly cast because predicted values tend to be of DF type object</span>
                <span class="n">means</span> <span class="o">=</span> <span class="n">grouped_series</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">sd</span> <span class="o">=</span> <span class="n">grouped_series</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># unbiased (1 degree of freedom)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">grouped_series</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
                <span class="c1">#se = sd / np.sqrt(n) </span>
                <span class="c1">#upper_band = means + (stderr_bar_multiple * se)</span>
                <span class="c1">#lower_band = means - (stderr_bar_multiple * se)</span>
                <span class="n">upper_band</span> <span class="o">=</span> <span class="n">means</span> <span class="o">+</span> <span class="p">(</span><span class="n">stdev_bar_multiple</span> <span class="o">*</span> <span class="n">sd</span><span class="p">)</span>
                <span class="n">lower_band</span> <span class="o">=</span> <span class="n">means</span> <span class="o">-</span> <span class="p">(</span><span class="n">stdev_bar_multiple</span> <span class="o">*</span> <span class="n">sd</span><span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">upper_band</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightslategray&#39;</span><span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">lower_band</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightslategray&#39;</span><span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span> <span class="c1"># plot on top of the bands</span>
                <span class="c1">#ax = data_weather._select_df_obs_vs_times()[value_colname].unstack().transpose().plot(legend=False, grid=True)</span>
                <span class="c1">#ylabel = &#39;Mean of &#39; + value_colname + &#39;\n&#39; + &#39;+/- &#39; + str(stderr_bar_multiple) + &#39; S.E.&#39;</span>
                <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;Mean of &#39;</span> <span class="o">+</span> <span class="n">value_colname</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;+/- &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">stdev_bar_multiple</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; S.D.&#39;</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>                
                <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_colnames_vs_series</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Will not plot means for &#39;</span> <span class="o">+</span> <span class="n">value_colname</span> <span class="o">+</span> <span class="s1">&#39; because it is not a time label&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Unknown feature &#39;</span> <span class="o">+</span> <span class="n">value_colname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axes</span></div>
             
        
    <span class="c1"># Returns a tuple (new instance for the given times, new instance for all remaining other times)</span>
<div class="viewcode-block" id="MultiSeries.split_by_times"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.split_by_times">[docs]</a>    <span class="k">def</span> <span class="nf">split_by_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">given_times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_full</span><span class="p">,</span> <span class="n">given_times</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No other times were found beyond the given times: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">given_times</span><span class="p">))</span>
        <span class="n">new_instance_given_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_times</span><span class="p">(</span><span class="n">new_time_uniques</span><span class="o">=</span><span class="n">given_times</span><span class="p">,</span> <span class="n">require_times_to_be_subset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_instance_other_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_times</span><span class="p">(</span><span class="n">new_time_uniques</span><span class="o">=</span><span class="n">other_times</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">new_instance_given_times</span><span class="p">,</span> <span class="n">new_instance_other_times</span><span class="p">)</span></div>
        
        
    <span class="c1"># Returns a single value. Useful for when split_by_times() cannot be called (when we&#39;re in the middle of updating the data).</span>
<div class="viewcode-block" id="MultiSeries.subset_by_times"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.subset_by_times">[docs]</a>    <span class="k">def</span> <span class="nf">subset_by_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">given_times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_instance_given_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_times</span><span class="p">(</span><span class="n">new_time_uniques</span><span class="o">=</span><span class="n">given_times</span><span class="p">,</span> <span class="n">require_times_to_be_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_instance_given_times</span></div>
        
        
<div class="viewcode-block" id="MultiSeries.get_backward_time_window"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.get_backward_time_window">[docs]</a>    <span class="k">def</span> <span class="nf">get_backward_time_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">time_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">allow_missing_values</span><span class="p">:</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_full</span>
        <span class="n">count_timestamps</span> <span class="o">=</span> <span class="n">timestamps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">window_size</span> <span class="o">&gt;</span> <span class="n">count_timestamps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There are not enough timestamps for the given parameters window_size=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, allow_missing_values=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">allow_missing_values</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. The &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_timestamps</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;available timestamps are &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timestamps</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">time_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[</span><span class="o">-</span><span class="n">window_size</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_of_time_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">timestamps</span> <span class="o">==</span> <span class="n">time_limit</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[(</span><span class="n">idx_of_time_limit</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">)</span> <span class="p">:</span> <span class="n">idx_of_time_limit</span><span class="p">]</span>
        
        <span class="p">(</span><span class="n">new_instance_sliding_window</span><span class="p">,</span> <span class="n">new_instance_other_times</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_by_times</span><span class="p">(</span><span class="n">given_times</span><span class="o">=</span><span class="n">subset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_instance_sliding_window</span></div>
        
        
<div class="viewcode-block" id="MultiSeries.get_forward_time_window"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.get_forward_time_window">[docs]</a>    <span class="k">def</span> <span class="nf">get_forward_time_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">time_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_missing_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">allow_missing_values</span><span class="p">:</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_full</span>
        <span class="n">count_timestamps</span> <span class="o">=</span> <span class="n">timestamps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">window_size</span> <span class="o">&gt;</span> <span class="n">count_timestamps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;There are not enough timestamps for the given parameters window_size=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, allow_missing_values=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">allow_missing_values</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. The &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_timestamps</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;available timestamps are &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timestamps</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">time_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[:</span><span class="n">window_size</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_of_time_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">timestamps</span> <span class="o">==</span> <span class="n">time_limit</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[(</span><span class="n">idx_of_time_limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">idx_of_time_limit</span> <span class="o">+</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        
        <span class="p">(</span><span class="n">new_instance_sliding_window</span><span class="p">,</span> <span class="n">new_instance_other_times</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_by_times</span><span class="p">(</span><span class="n">given_times</span><span class="o">=</span><span class="n">subset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_instance_sliding_window</span></div>
        
        
    <span class="c1"># Utility method to get the internal indices of the boundaries of the given time values - useful for interacting with the statsmodels library.</span>
<div class="viewcode-block" id="MultiSeries.get_time_boundary_indices"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.get_time_boundary_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_time_boundary_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">given_times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">given_times</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">given_times</span><span class="p">)</span>
        <span class="n">start_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_times</span> <span class="o">==</span> <span class="n">start_time</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_times</span> <span class="o">==</span> <span class="n">end_time</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected a single instance of time &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; and instead found &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_indices</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">all_times</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected a single instance of time &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; and instead found &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_indices</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">all_times</span><span class="p">))</span>
        <span class="n">start_index</span> <span class="o">=</span> <span class="n">start_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end_index</span> <span class="o">=</span> <span class="n">end_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span></div>
        
        
    <span class="c1"># Generates a tuple of (training MultiSeries object, validation MultiSeries object) using K-fold CV for i.i.d. series</span>
<div class="viewcode-block" id="MultiSeries.generate_series_folds"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.generate_series_folds">[docs]</a>    <span class="k">def</span> <span class="nf">generate_series_folds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series_splitter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Yields:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">series_splitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">series_splitter</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No seriesSplitter was given, so using &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">series_splitter</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">training_series_ids_indices</span><span class="p">,</span> <span class="n">validation_series_ids_indices</span><span class="p">)</span> <span class="ow">in</span> <span class="n">series_splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Make sure they are sorted so we can use them for MultiIndex slicing later on:</span>
            <span class="n">training_series_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">[</span><span class="n">training_series_ids_indices</span><span class="p">])</span>
            <span class="n">validation_series_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">[</span><span class="n">validation_series_ids_indices</span><span class="p">])</span>
            <span class="n">count_training_series</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_series_ids</span><span class="p">)</span>
            <span class="n">count_validation_series</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation_series_ids</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Split &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: training/validation series split of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_training_series</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_validation_series</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_training_series</span><span class="o">+</span><span class="n">count_validation_series</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; total.&#39;</span><span class="p">)</span>
            <span class="n">training_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_series_ids</span><span class="p">(</span><span class="n">training_series_ids</span><span class="p">)</span>
            <span class="n">validation_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_series_ids</span><span class="p">(</span><span class="n">validation_series_ids</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">training_instance</span><span class="p">,</span> <span class="n">validation_instance</span><span class="p">)</span></div>
    
            
    <span class="c1"># timeSeriesSplitter should be an implementation of AbstractTimeSeriesSplit</span>
<div class="viewcode-block" id="MultiSeries.generate_time_windows"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.generate_time_windows">[docs]</a>    <span class="k">def</span> <span class="nf">generate_time_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_splitter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Yields:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">training_time_indices</span><span class="p">,</span> <span class="n">validation_time_indices</span><span class="p">)</span> <span class="ow">in</span> <span class="n">time_splitter</span><span class="p">:</span>
            <span class="n">training_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span><span class="p">[</span><span class="n">training_time_indices</span><span class="p">]</span>
            <span class="n">validation_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span><span class="p">[</span><span class="n">validation_time_indices</span><span class="p">]</span>
            <span class="c1">#count_training_times = len(training_times)</span>
            <span class="c1">#count_validation_times = len(validation_times)</span>
            <span class="n">training_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_times</span><span class="p">(</span><span class="n">training_times</span><span class="p">)</span>
            <span class="n">validation_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_times</span><span class="p">(</span><span class="n">validation_times</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">training_instance</span><span class="p">,</span> <span class="n">validation_instance</span><span class="p">)</span></div>
            
            
    <span class="c1"># Uses this instance of the MultiSeries &amp; the given times 1D array as a template to convert the given 2D array to a 3D array to a MultiSeries</span>
<div class="viewcode-block" id="MultiSeries.new_instance_from_2d_array"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.new_instance_from_2d_array">[docs]</a>    <span class="k">def</span> <span class="nf">new_instance_from_2d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Y_a2d</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">prediction_features</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count_series</span> <span class="o">=</span> <span class="n">Y_a2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">count_times</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="n">count_total_features</span> <span class="o">=</span> <span class="n">Y_a2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">count_original_features</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">count_total_features</span> <span class="o">/</span> <span class="n">count_times</span><span class="p">))</span> <span class="c1"># enforce integer type due to warning in numpy&#39;s reshape() method</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count_original_features</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Detected &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_original_features</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; original features, will now reshape from a 2D &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Y_a2d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; array to a 3D (&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_series</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_times</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_original_features</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;) array&#39;</span><span class="p">)</span>
        <span class="n">Y_a3d</span> <span class="o">=</span> <span class="n">Y_a2d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">count_series</span><span class="p">,</span> <span class="n">count_times</span><span class="p">,</span> <span class="n">count_original_features</span><span class="p">)</span>
        <span class="n">Y_multiseries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_instance_from_3d_array</span><span class="p">(</span><span class="n">a3d_vs_times</span><span class="o">=</span><span class="n">Y_a3d</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="o">=</span><span class="n">prediction_features</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Y_multiseries</span></div>
        
    
    <span class="k">def</span> <span class="nf">_new_data_vs_times_df_from_3d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="p">,</span> <span class="n">series_id_uniques</span><span class="p">):</span>
        <span class="c1"># Prepare empty data DFs</span>
        <span class="n">new_data_vs_times_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">value_colnames_vs_times</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">,</span> <span class="n">times</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">]))</span>
        <span class="c1">#new_data_vs_series_df = pd.DataFrame(columns=value_colnames_vs_series, index=pd.Index(data=self._series_id_uniques, name=self._series_id_colname))</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">times_list</span> <span class="o">=</span> <span class="n">times</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">times_list</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="c1"># Set the per-time DF with the given values, if specified</span>
        <span class="k">for</span> <span class="n">series_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a3d_vs_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">series_id</span> <span class="o">=</span> <span class="n">series_id_uniques</span><span class="p">[</span><span class="n">series_idx</span><span class="p">]</span>  <span class="c1"># look up series ID from the given index</span>
            <span class="c1">#self.debug(&#39;series_idx=&#39; + str(series_idx) + &#39;, series_id=&#39; + str(series_id))</span>
            <span class="c1"># Notes on the next 2 lines, one inside the loop and one outside:</span>
            <span class="c1">#   - the only columns in our DF are value cols so this is safe to do</span>
            <span class="c1">#   - indexers (inclucing iloc) used for setting do this setting inline</span>
            <span class="c1">#   - however, there is no guarantee that new_df itself is a view rather than a copy so we reassign that... refer to</span>
            <span class="c1">#       + https://stackoverflow.com/questions/23296282/what-rules-does-pandas-use-to-generate-a-view-vs-a-copy</span>
            <span class="c1">#       + http://pandas-docs.github.io/pandas-docs-travis/indexing.html#indexing-view-versus-copy</span>
            <span class="n">new_data_vs_times_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">series_id</span><span class="p">,</span> <span class="n">times_list</span><span class="p">),</span> <span class="n">value_colnames_vs_times</span><span class="p">]</span> <span class="o">=</span> <span class="n">a3d_vs_times</span><span class="p">[</span><span class="n">series_idx</span><span class="p">,:,:]</span>   
        
        <span class="k">return</span> <span class="n">new_data_vs_times_df</span>
        
    
    <span class="k">def</span> <span class="nf">_new_data_vs_times_df_from_2d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">series_idx</span><span class="p">,</span> <span class="n">a2d_vs_times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="p">,</span> <span class="n">series_id_uniques</span><span class="p">):</span>
        <span class="c1"># Prepare empty data DFs</span>
        <span class="n">new_data_vs_times_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">value_colnames_vs_times</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">,</span> <span class="n">times</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">]))</span>
        <span class="c1">#new_data_vs_series_df = pd.DataFrame(columns=value_colnames_vs_series, index=pd.Index(data=self._series_id_uniques, name=self._series_id_colname))</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">times_list</span> <span class="o">=</span> <span class="n">times</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">times_list</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="c1"># Look up series ID from the given index</span>
        <span class="n">series_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">[</span><span class="n">series_idx</span><span class="p">]</span>  
            
        <span class="c1"># Set the per-time DF with the given values, if specified</span>
        <span class="n">new_data_vs_times_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">series_id</span><span class="p">,</span> <span class="n">times_list</span><span class="p">),</span> <span class="n">value_colnames_vs_times</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2d_vs_times</span>  
            
        <span class="k">return</span> <span class="n">new_data_vs_times_df</span>
        
            
    <span class="c1"># Instantiate a new instance based off the current instance (Prototype design pattern).</span>
    <span class="c1"># Parameter a3d_vs_times should have shape (# series, # timestamps, # features).</span>
    <span class="c1"># Parameter &quot;times&quot; should be a subset of the existing prediction times. If it is not, you should use new_mutable_instance() + update_from_3d_array() instead.</span>
<div class="viewcode-block" id="MultiSeries.new_instance_from_3d_array"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.new_instance_from_3d_array">[docs]</a>    <span class="k">def</span> <span class="nf">new_instance_from_3d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="c1">#def new_instance_from_3d_array(self, times, a3d_vs_times=None, value_colnames_vs_times=None, a2d_vs_series=None, value_colnames_vs_series=None):</span>
        <span class="c1"># As well as the copy of the attributes, create an empty copy of the DF</span>
        <span class="n">new_instance</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># shallow clone</span>
        
        <span class="c1"># Infer value_colnames_vs_times</span>
        <span class="k">if</span> <span class="n">value_colnames_vs_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value_colnames_vs_times</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">value_colnames_vs_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_colnames_vs_times</span><span class="p">]</span> <span class="c1"># required</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Passed in value_colnames_vs_times = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value_colnames_vs_times</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_colnames_vs_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Using default value_colnames_vs_times = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value_colnames_vs_times</span><span class="p">))</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span> <span class="o">=</span> <span class="n">value_colnames_vs_times</span>
        
        <span class="c1"># Create a DF from the 3D array...</span>
        <span class="n">new_data_vs_times_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_data_vs_times_df_from_3d_array</span><span class="p">(</span><span class="n">series_id_uniques</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">a3d_vs_times</span><span class="o">=</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="o">=</span><span class="n">value_colnames_vs_times</span><span class="p">)</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_times_df</span> <span class="o">=</span> <span class="n">new_data_vs_times_df</span>
          
        <span class="c1"># ... and create a new index of observations based off the actual values</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_filter_obs</span> <span class="o">=</span> <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_derived_filters</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">new_instance</span></div>
       
    
<div class="viewcode-block" id="MultiSeries.update_from_3d_array"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.update_from_3d_array">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_3d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="p">):</span>    
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="c1"># Collect the new data in a similar DF</span>
        <span class="n">new_data_vs_times_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_data_vs_times_df_from_3d_array</span><span class="p">(</span><span class="n">series_id_uniques</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">a3d_vs_times</span><span class="o">=</span><span class="n">a3d_vs_times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="o">=</span><span class="n">value_colnames_vs_times</span><span class="p">)</span>
        
        <span class="c1"># Set the per-time DF with the given values, if specified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_data_vs_times_df</span><span class="p">)</span>
                   
        <span class="c1"># ... and create a new index of observations based off the actual values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_derived_filters</span><span class="p">()</span></div>
            
          
<div class="viewcode-block" id="MultiSeries.update_from_2d_array"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.update_from_2d_array">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_2d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series_idx</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">a2d_vs_times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Collect the new data in a similar DF</span>
        <span class="n">new_data_vs_times_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_data_vs_times_df_from_2d_array</span><span class="p">(</span><span class="n">series_idx</span><span class="o">=</span><span class="n">series_idx</span><span class="p">,</span> <span class="n">series_id_uniques</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">a2d_vs_times</span><span class="o">=</span><span class="n">a2d_vs_times</span><span class="p">,</span> <span class="n">value_colnames_vs_times</span><span class="o">=</span><span class="n">value_colnames_vs_times</span><span class="p">)</span>
        
        <span class="c1"># Set the per-time DF with the given values, if specified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_data_vs_times_df</span><span class="p">)</span> 
        
        <span class="c1"># ... and create a new index of observations based off the actual values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_derived_filters</span><span class="p">()</span></div>
        
    
    <span class="c1"># Create a new instance with values at the given prediction_times wiped out. (Other times remain untouched.)</span>
    <span class="c1"># This is so we can use this instance to keep track of all the intermediate &amp; final predicitons for various columns.</span>
<div class="viewcode-block" id="MultiSeries.new_mutable_instance"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.new_mutable_instance">[docs]</a>    <span class="k">def</span> <span class="nf">new_mutable_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_value_colnames_vs_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prediction_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_instance</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># shallow clone</span>
        
        <span class="c1"># Copy whole/subset of time labels DF</span>
        <span class="k">if</span> <span class="n">filter_value_colnames_vs_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_times_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_obs_vs_times</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1">#new_instance._data_vs_times_df = self._select_df_obs_vs_times()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">filter_value_colnames_vs_times</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">filter_value_colnames_vs_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">filter_value_colnames_vs_times</span><span class="p">]</span>
                <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_times_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_obs_vs_times</span><span class="p">()[</span><span class="n">filter_value_colnames_vs_times</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_instance</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span> <span class="o">=</span> <span class="n">filter_value_colnames_vs_times</span>
                
        <span class="c1"># Copy whole series labels DF, if applicable</span>
        <span class="n">series_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_df_vs_series</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">series_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_series_df</span> <span class="o">=</span> <span class="n">series_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
        <span class="c1"># Add some new times to the given DF index &amp; other internals, so that we can set values on these later on.</span>
        <span class="k">if</span> <span class="n">prediction_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            
            <span class="n">additional_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">prediction_times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">additional_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;additional_times = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">additional_times</span><span class="p">))</span>
                <span class="c1"># Append to the times being tracked</span>
                <span class="n">new_instance</span><span class="o">.</span><span class="n">_time_uniques_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">additional_times</span><span class="p">)</span>
                
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">,</span> <span class="n">new_instance</span><span class="o">.</span><span class="n">_time_uniques_all</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">])</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_times_df</span> <span class="o">=</span> <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_times_df</span> <span class="o">=</span> <span class="n">new_instance</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span> <span class="c1"># necessary to avoid lexical sort exception when updating later</span>
        
        <span class="k">return</span> <span class="n">new_instance</span></div>
        
 
    <span class="c1"># Call this on Y_true. The residuals are calculated as simply (Y_true - Y_hat) for all dimensions.</span>
    <span class="c1"># Returns as an xarray.DataArray.</span>
    <span class="c1"># Residuals are added up across all features, so to get the residuals for a single feature, specify it in the value_colnames_filter param.</span>
    <span class="c1"># TODO: this only acts on residuals for time labels. Consider whether to expand this to cover series labels too, and if so, how?!</span>
<div class="viewcode-block" id="MultiSeries.get_raw_residuals"><a class="viewcode-back" href="../../index.html#pysf.data.MultiSeries.get_raw_residuals">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Y_hat</span><span class="p">,</span> <span class="n">value_colnames_vs_times_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class methods are similar to regular functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            param1: The first parameter.</span>
<span class="sd">            param2: The second parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if successful, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Y_true</span> <span class="o">=</span> <span class="bp">self</span> <span class="c1"># for clarity in the code</span>
        <span class="k">if</span> <span class="n">value_colnames_vs_times_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_colnames_vs_times_filter</span> <span class="o">=</span> <span class="n">Y_hat</span><span class="o">.</span><span class="n">_value_colnames_vs_times</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value_colnames_vs_times_filter</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">value_colnames_vs_times_filter</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_colnames_vs_times_filter</span><span class="p">]</span> <span class="c1"># necessary to avoid implicit conversion of DF -&gt; Series</span>
        <span class="n">residuals_raw_df</span> <span class="o">=</span> <span class="p">(</span><span class="n">Y_true</span><span class="o">.</span><span class="n">_select_df_obs_vs_times</span><span class="p">()[</span><span class="n">value_colnames_vs_times_filter</span><span class="p">]</span> <span class="o">-</span> <span class="n">Y_hat</span><span class="o">.</span><span class="n">_select_df_obs_vs_times</span><span class="p">()[</span><span class="n">value_colnames_vs_times_filter</span><span class="p">])</span>
        <span class="c1"># Sum across all features (i.e. value columns) to get overall residuals. This also converts the DF to a Series (still with a MultiIndex):</span>
        <span class="n">residuals_raw_multiseries</span> <span class="o">=</span> <span class="n">residuals_raw_df</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        <span class="c1"># Cast this to an xarray.DataArray and set the column names to something standard</span>
        <span class="c1"># The next 2 lines aim to make the DataArray as sparse as possible by dropping unused levels on the MultiIndex levels.</span>
        <span class="n">residuals_raw_multiseries</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">residuals_raw_multiseries</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">remove_unused_levels</span><span class="p">()</span> <span class="c1"># requires pandas &gt;= 0.20</span>
        <span class="n">residuals_raw_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">from_series</span><span class="p">(</span><span class="n">residuals_raw_multiseries</span><span class="p">)</span> <span class="c1"># this sizes the DA as a tensor product of _levels_ not values</span>
        <span class="n">residuals_raw_da</span> <span class="o">=</span> <span class="n">residuals_raw_da</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span> <span class="n">Y_true</span><span class="o">.</span><span class="n">_series_id_colname</span> <span class="p">:</span> <span class="s1">&#39;series&#39;</span><span class="p">,</span> <span class="n">Y_true</span><span class="o">.</span><span class="n">_time_colname</span> <span class="p">:</span> <span class="s1">&#39;timestamp&#39;</span> <span class="p">})</span>
        <span class="c1"># Wrap it up in a RawResiduals obj:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">RawResiduals</span><span class="p">(</span><span class="n">residuals_raw</span><span class="o">=</span><span class="n">residuals_raw_da</span><span class="p">,</span> <span class="n">feature_colnames</span><span class="o">=</span><span class="n">value_colnames_vs_times_filter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>        </div>
        
        
    <span class="c1"># Instantiate a new instance based off the current instance (Prototype design pattern).</span>
    <span class="k">def</span> <span class="nf">__new_instance_from_series_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_series_id_uniques</span><span class="p">):</span>
        <span class="c1"># Validation</span>
        <span class="n">missing_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">new_series_id_uniques</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_series_id_uniques</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">missing_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">missing_ids</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of the given new_series_id_uniques were not found in the current series IDs, and they are: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">missing_ids</span><span class="p">))</span>
        <span class="c1"># Selection</span>
        <span class="c1"># TODO: is this efficient, or are we better off indexing using [ , ] instead of get_level_values().isin():</span>
        <span class="n">new_filter_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">new_series_id_uniques</span><span class="p">)]</span>
        <span class="n">new_time_uniques</span> <span class="o">=</span> <span class="n">new_filter_obs</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_time_uniques</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">new_time_uniques</span> <span class="o">=</span> <span class="n">new_time_uniques</span><span class="o">.</span><span class="n">values</span>
        <span class="n">new_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_filter</span><span class="p">(</span><span class="n">new_filter_obs</span><span class="o">=</span><span class="n">new_filter_obs</span><span class="p">,</span> <span class="n">new_series_id_uniques</span><span class="o">=</span><span class="n">new_series_id_uniques</span><span class="p">,</span> <span class="n">new_time_uniques</span><span class="o">=</span><span class="n">new_time_uniques</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_instance</span>
        
        
    <span class="c1"># Instantiate a new instance based off the current instance (Prototype design pattern).</span>
    <span class="k">def</span> <span class="nf">__new_instance_from_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_time_uniques</span><span class="p">,</span> <span class="n">require_times_to_be_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Deal with special case</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_time_uniques</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
            
        <span class="c1"># Validation, unless &quot;new&quot; times are allowed</span>
        <span class="k">if</span> <span class="n">require_times_to_be_subset</span><span class="p">:</span>
            <span class="n">missing_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">new_time_uniques</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_uniques_all</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">missing_ids</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">missing_ids</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of the given new_time_uniques were not found in the current times, and they are: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">missing_ids</span><span class="p">))</span>
                <span class="c1">#self.warning(str(missing_ids.size) + &#39; of the given new_time_uniques were not found in the current to,es, and they are: &#39; + str(missing_ids))</span>
                
        <span class="c1"># Selection</span>
        <span class="c1"># TODO: is this efficient, or are we better off indexing using [ , ] instead of get_level_values().isin():</span>
        <span class="n">new_filter_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_obs</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_colname</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">new_time_uniques</span><span class="p">)]</span>
        <span class="n">new_series_id_uniques</span> <span class="o">=</span> <span class="n">new_filter_obs</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_series_id_colname</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_series_id_uniques</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">new_series_id_uniques</span> <span class="o">=</span> <span class="n">new_series_id_uniques</span><span class="o">.</span><span class="n">values</span>
        <span class="n">new_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new_instance_from_filter</span><span class="p">(</span><span class="n">new_filter_obs</span><span class="o">=</span><span class="n">new_filter_obs</span><span class="p">,</span> <span class="n">new_series_id_uniques</span><span class="o">=</span><span class="n">new_series_id_uniques</span><span class="p">,</span> <span class="n">new_time_uniques</span><span class="o">=</span><span class="n">new_time_uniques</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_instance</span>
    
        
    <span class="c1"># Instantiate a new instance based off the current instance (Prototype design pattern).</span>
    <span class="k">def</span> <span class="nf">__new_instance_from_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_filter_obs</span><span class="p">,</span> <span class="n">new_series_id_uniques</span><span class="p">,</span> <span class="n">new_time_uniques</span><span class="p">):</span>
        <span class="n">new_instance</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># shallow copy</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_filter_obs</span> <span class="o">=</span> <span class="n">new_filter_obs</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_series_id_uniques</span> <span class="o">=</span> <span class="n">new_series_id_uniques</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_count_series_indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_series_id_uniques</span><span class="p">)</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_time_uniques_all</span> <span class="o">=</span> <span class="n">new_time_uniques</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_count_time_indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_time_uniques</span><span class="p">)</span>
        <span class="n">new_instance</span><span class="o">.</span><span class="n">_set_derived_filters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Built new instance &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_instance</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_instance</span>

        
    <span class="c1"># This syntax allows str(obj) to be called on an instance obj of our class</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rows_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_observations</span>
        <span class="n">rows_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_vs_times_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;(filtering &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rows_filtered</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rows_total</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; observations, over &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count_series_indices</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; series x &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count_time_indices</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; timestamps x &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count_features</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; features)&#39;</span><span class="p">)</span></div>
    

        
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pysf 0.0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Ahmed Guecioueur.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>